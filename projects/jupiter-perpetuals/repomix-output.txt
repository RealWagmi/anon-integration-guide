This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-30T03:24:38.023Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
__tests__/
  functions/
    getBorrowRates.test.ts
  services/
    perpsApi.test.ts
functions/
  getBorrowRates.ts
  index.ts
scripts/
  compareRates.ts
services/
  accountMonitor.ts
  logger.ts
  perpsApi.ts
.gitignore
.prettierrc
config.ts
constants.ts
index.ts
jest.config.js
layouts.ts
package.json
README.md
tools.ts
tsconfig.json
types.ts

================================================================
Files
================================================================

================
File: __tests__/functions/getBorrowRates.test.ts
================
import { getBorrowRates } from '../../functions/getBorrowRates';
import { PerpsApiService } from '../../services/perpsApi';

jest.mock('../../services/perpsApi');

describe('getBorrowRates', () => {
    const mockPoolInfo = {
        longAvailableLiquidity: "1000000",
        longBorrowRatePercent: "10.5",
        longUtilizationPercent: "75.5",
        shortAvailableLiquidity: "2000000",
        shortBorrowRatePercent: "12.5",
        shortUtilizationPercent: "80.5",
        openFeePercent: "0.1",
        maxRequestExecutionSec: "30"
    };

    beforeEach(() => {
        jest.clearAllMocks();
        jest.useFakeTimers();
        jest.setSystemTime(new Date(2024, 0, 1));
    });

    afterEach(() => {
        jest.useRealTimers();
    });

    it('should return rates for valid asset', async () => {
        (PerpsApiService.getPoolInfo as jest.Mock).mockResolvedValue(mockPoolInfo);

        const result = await getBorrowRates({ asset: 'SOL' });
        
        expect(result.error).toBe(false);
        const parsed = JSON.parse(result.data);
        expect(parsed).toEqual({
            asset: 'SOL',
            long: {
                borrowRate: 10.5,
                utilization: 75.5,
                availableLiquidity: 1000000
            },
            short: {
                borrowRate: 12.5,
                utilization: 80.5,
                availableLiquidity: 2000000
            },
            openFee: 0.1,
            timestamp: new Date(2024, 0, 1).getTime()
        });
    });

    it('should return error for invalid asset', async () => {
        const result = await getBorrowRates({ asset: 'INVALID' as any });
        
        expect(result.error).toBe(true);
        expect(result.data).toContain('Invalid asset');
    });

    it('should handle API errors', async () => {
        (PerpsApiService.getPoolInfo as jest.Mock).mockRejectedValue(new Error('API Error'));

        const result = await getBorrowRates({ asset: 'SOL' });
        
        expect(result.error).toBe(true);
        expect(result.data).toContain('Error fetching borrow rates');
    });
});

================
File: __tests__/services/perpsApi.test.ts
================
import { PerpsApiService, PoolInfo } from '../../services/perpsApi';

describe('PerpsApiService', () => {
    const mockPoolInfo: PoolInfo = {
        longAvailableLiquidity: "1000000",
        longBorrowRatePercent: "10.5",
        longUtilizationPercent: "75.5",
        shortAvailableLiquidity: "2000000",
        shortBorrowRatePercent: "12.5",
        shortUtilizationPercent: "80.5",
        openFeePercent: "0.1",
        maxRequestExecutionSec: "30"
    };

    beforeEach(() => {
        jest.useFakeTimers();
        jest.setSystemTime(new Date(2024, 0, 1));
    });

    afterEach(() => {
        jest.useRealTimers();
        jest.restoreAllMocks();
    });

    describe('getPoolInfo', () => {
        it('should fetch pool info successfully', async () => {
            global.fetch = jest.fn().mockResolvedValue({
                ok: true,
                json: () => Promise.resolve(mockPoolInfo)
            });

            const result = await PerpsApiService.getPoolInfo('testMint');
            expect(result).toEqual(mockPoolInfo);
            expect(fetch).toHaveBeenCalledWith('https://perps-api.jup.ag/v1/pool-info?mint=testMint');
        });

        it('should throw error when fetch fails', async () => {
            global.fetch = jest.fn().mockResolvedValue({
                ok: false,
                statusText: 'Not Found'
            });

            await expect(PerpsApiService.getPoolInfo('testMint'))
                .rejects
                .toThrow('API error: Not Found');
        });
    });

    describe('parsePoolInfo', () => {
        it('should correctly parse pool info', () => {
            const result = PerpsApiService.parsePoolInfo(mockPoolInfo);

            expect(result).toEqual({
                long: {
                    borrowRate: 10.5,
                    utilization: 75.5,
                    availableLiquidity: 1000000
                },
                short: {
                    borrowRate: 12.5,
                    utilization: 80.5,
                    availableLiquidity: 2000000
                },
                openFee: 0.1,
                timestamp: new Date(2024, 0, 1).getTime()
            });
        });
    });
});

================
File: functions/getBorrowRates.ts
================
import { FunctionReturn, toResult } from '@heyanon/sdk';
import { CUSTODY_ACCOUNTS, AssetType, PerpsMarketData } from '../types';
import { PerpsApiService } from '../services/perpsApi';

interface Props {
    asset: AssetType;
}

/**
 * Gets current borrow rates for Jupiter Perpetuals markets using their API
 * Returns rates for both long and short positions
 * 
 * @param {Props} props - Asset to get rates for 
 * @returns {Promise<FunctionReturn>} Object containing:
 *   - long: {borrowRate, utilization, availableLiquidity}
 *   - short: {borrowRate, utilization, availableLiquidity}
 *   - openFee: Opening fee percentage
 *   - timestamp: Current timestamp
 */
export async function getBorrowRates({ asset }: Props): Promise<FunctionReturn> {
    try {
        if (!CUSTODY_ACCOUNTS[asset]) {
            return toResult(
                `Invalid asset: ${asset}. Must be one of: ${Object.keys(CUSTODY_ACCOUNTS).join(', ')}`,
                true
            );
        }

        const poolInfo = await PerpsApiService.getPoolInfo(CUSTODY_ACCOUNTS[asset]);
        const rates: PerpsMarketData = PerpsApiService.parsePoolInfo(poolInfo);

        const response = {
            asset,
            ...rates
        };

        return toResult(JSON.stringify(response));
    } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        return toResult(`Error fetching borrow rates: ${errorMessage}`, true);
    }
}

================
File: functions/index.ts
================
export { getBorrowRates } from './getBorrowRates';

================
File: scripts/compareRates.ts
================
import { AccountMonitor } from '../services/accountMonitor';
import { AssetType } from '../types';

// Define the rate data interface if it's not already defined in types.ts
interface RateData {
    utilization: number;
    annualRate: number;
    hourlyRate: number;
    timestamp: number;
}

async function compareJupiterRates() {
    // Create a new monitor instance with default RPC URL
    const monitor = new AccountMonitor('https://api.mainnet-beta.solana.com');
    
    // Get current rates for SOL
    const solRates = await monitor.getCurrentRates('SOL' as AssetType);
    
    if (solRates) {
        console.log('SOL Rates Comparison');
        console.log('-------------------');
        console.log('Our calculation:');
        console.log(`Hourly Rate: ${solRates.hourlyRate.toFixed(4)}% / hr`);
        console.log(`Utilization: ${solRates.utilization.toFixed(2)}%`);
        console.log('\nCompare these numbers with:');
        console.log('https://jup.ag/perps');
    }

    // Keep monitoring for changes
    monitor.onRateUpdate((asset: AssetType, rates: RateData) => {
        if (asset === 'SOL') {
            console.log(`\n[${new Date().toISOString()}] Rate Update:`);
            console.log(`Hourly Rate: ${rates.hourlyRate.toFixed(4)}% / hr`);
            console.log(`Utilization: ${rates.utilization.toFixed(2)}%`);
        }
    });

    await monitor.start();

    // Keep the process running
    console.log('\nMonitoring for rate changes... (Ctrl+C to stop)');

    // Handle cleanup on process exit
    process.on('SIGINT', async () => {
        console.log('\nStopping monitor...');
        await monitor.stop();
        process.exit();
    });
}

compareJupiterRates().catch(console.error);

================
File: services/accountMonitor.ts
================
import { AssetType, CUSTODY_ACCOUNTS, PerpsMarketData } from '../types';
import { PerpsApiService } from './perpsApi';
import { Logger, ConsoleLogger } from './logger';

export class AccountMonitor {
    private pollInterval: NodeJS.Timeout | null = null;
    private rateCallbacks: Set<(asset: AssetType, rates: PerpsMarketData) => void>;
    private isRunning: boolean;
    private logger: Logger;
    private lastRates: Map<AssetType, PerpsMarketData>;

    constructor(logger: Logger = new ConsoleLogger()) {
        this.rateCallbacks = new Set();
        this.isRunning = false;
        this.logger = logger;
        this.lastRates = new Map();
    }

    async start() {
        if (this.isRunning) {
            return;
        }

        this.isRunning = true;
        this.logger.info('Starting account monitor...');

        // Initial fetch for all assets
        for (const asset of Object.keys(CUSTODY_ACCOUNTS) as AssetType[]) {
            try {
                await this.fetchAndUpdateRates(asset);
            } catch (error) {
                this.logger.error(`Error fetching initial rates for ${asset}:`, error);
            }
        }

        // Set up polling
        this.pollInterval = setInterval(async () => {
            for (const asset of Object.keys(CUSTODY_ACCOUNTS) as AssetType[]) {
                try {
                    await this.fetchAndUpdateRates(asset);
                } catch (error) {
                    this.logger.error(`Error polling rates for ${asset}:`, error);
                }
            }
        }, 5000); // Poll every 5 seconds
    }

    async stop() {
        if (!this.isRunning) {
            return;
        }
        
        this.isRunning = false;
        this.logger.info('Stopping account monitor...');
        
        if (this.pollInterval) {
            clearInterval(this.pollInterval);
            this.pollInterval = null;
        }
        
        this.rateCallbacks.clear();
        this.lastRates.clear();
    }

    onRateUpdate(callback: (asset: AssetType, rates: PerpsMarketData) => void) {
        this.rateCallbacks.add(callback);
        
        // Immediately send latest rates if available
        for (const [asset, rates] of this.lastRates.entries()) {
            callback(asset, rates);
        }
        
        return () => {
            this.rateCallbacks.delete(callback);
        };
    }

    async getCurrentRates(asset: AssetType): Promise<PerpsMarketData | null> {
        try {
            const poolInfo = await PerpsApiService.getPoolInfo(CUSTODY_ACCOUNTS[asset]);
            const rates = PerpsApiService.parsePoolInfo(poolInfo);
            return rates;
        } catch (error) {
            this.logger.error(`Error getting current rates for ${asset}:`, error);
            return null;
        }
    }

    private async fetchAndUpdateRates(asset: AssetType) {
        const rates = await this.getCurrentRates(asset);
        if (rates) {
            this.lastRates.set(asset, rates);
            for (const callback of this.rateCallbacks) {
                callback(asset, rates);
            }
        }
    }
}

export const accountMonitor = new AccountMonitor();
export default accountMonitor;

================
File: services/logger.ts
================
export interface Logger {
    error(message: string, ...args: any[]): void;
    info(message: string, ...args: any[]): void;
    debug(message: string, ...args: any[]): void;
    warn(message: string, ...args: any[]): void;
}

export class ConsoleLogger implements Logger {
    error(message: string, ...args: any[]): void {
        console.error(message, ...args);
    }

    info(message: string, ...args: any[]): void {
        console.info(message, ...args);
    }

    debug(message: string, ...args: any[]): void {
        console.debug(message, ...args);
    }

    warn(message: string, ...args: any[]): void {
        console.warn(message, ...args);
    }
}

export class TestLogger implements Logger {
    logs: { level: string; message: string; args: any[] }[] = [];

    error(message: string, ...args: any[]): void {
        this.logs.push({ level: 'error', message, args });
    }

    info(message: string, ...args: any[]): void {
        this.logs.push({ level: 'info', message, args });
    }

    debug(message: string, ...args: any[]): void {
        this.logs.push({ level: 'debug', message, args });
    }

    warn(message: string, ...args: any[]): void {
        this.logs.push({ level: 'warn', message, args });
    }

    clear(): void {
        this.logs = [];
    }
}

================
File: services/perpsApi.ts
================
export interface PoolInfo {
    longAvailableLiquidity: string;
    longBorrowRatePercent: string;
    longUtilizationPercent: string;
    shortAvailableLiquidity: string;
    shortBorrowRatePercent: string;
    shortUtilizationPercent: string;
    openFeePercent: string;
    maxRequestExecutionSec: string;
}

export interface PerpsRate {
    borrowRate: number;
    utilization: number;
    availableLiquidity: number;
}

export interface PerpsRates {
    long: PerpsRate;
    short: PerpsRate;
    openFee: number;
    timestamp: number;
}

export class PerpsApiService {
    private static BASE_URL = 'https://perps-api.jup.ag/v1';
    
    static async getPoolInfo(mint: string): Promise<PoolInfo> {
        const response = await fetch(`${this.BASE_URL}/pool-info?mint=${mint}`);
        if (!response.ok) {
            throw new Error(`API error: ${response.statusText}`);
        }
        return response.json();
    }

    static parsePoolInfo(poolInfo: PoolInfo): PerpsRates {
        return {
            long: {
                borrowRate: parseFloat(poolInfo.longBorrowRatePercent),
                utilization: parseFloat(poolInfo.longUtilizationPercent),
                availableLiquidity: parseFloat(poolInfo.longAvailableLiquidity)
            },
            short: {
                borrowRate: parseFloat(poolInfo.shortBorrowRatePercent),
                utilization: parseFloat(poolInfo.shortUtilizationPercent),
                availableLiquidity: parseFloat(poolInfo.shortAvailableLiquidity)
            },
            openFee: parseFloat(poolInfo.openFeePercent),
            timestamp: Date.now()
        };
    }
}

================
File: .gitignore
================
node_modules

================
File: .prettierrc
================
{
    "singleQuote": true,
    "trailingComma": "all",
    "tabWidth": 4,
    "printWidth": 180
}

================
File: config.ts
================
export const config = {
    rpcUrl: process.env.SOLANA_RPC_URL || 'https://api.mainnet-beta.solana.com',
    // Add other configuration settings here as needed
    snapshot: {
        interval: 5 * 60 * 1000,  // 5 minutes in milliseconds
        maxHistory: 168,          // Maximum hours of history to keep (1 week)
    },
    retry: {
        maxAttempts: 3,
        delay: 1000,              // 1 second between retries
    }
} as const;

================
File: constants.ts
================
import { ChainId } from '@heyanon/sdk';

export const supportedChains = [ChainId.SOLANA];

================
File: index.ts
================
import { AdapterExport } from '@heyanon/sdk'';
import { tools } from './tools';
import * as functions from './functions';

export default {
    tools,
    functions,
    description: 'Integration with Jupiter Funding Rates Data Streams',
} satisfies AdapterExport;

================
File: jest.config.js
================
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>'],
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  testRegex: '(/__tests__/.*|(\\.|/)(test|spec))\\.tsx?$',
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
};

================
File: layouts.ts
================
import { Buffer } from 'buffer';
import * as BufferLayout from '@solana/buffer-layout';
import { BN } from 'bn.js';

export interface DecodedAssets {
    feesReserves: bigint;
    owned: bigint;
    locked: bigint;
    guaranteedUsd: bigint;
    globalShortSizes: bigint;
    globalShortAveragePrices: bigint;
}

export interface DecodedFundingRateState {
    cumulativeInterestRate: bigint;
    lastUpdated: bigint;
    hourlyFundingDbps: bigint;
}

export interface DecodedJumpRateState {
    minRateBps: bigint;
    maxRateBps: bigint;
    targetRateBps: bigint;
    targetUtilizationRate: bigint;
}

export interface DecodedCustody {
    pool: number[];
    mint: number[];
    tokenAccount: number[];
    decimals: number;
    isStable: boolean;
    assets: DecodedAssets;
    fundingRateState: DecodedFundingRateState;
    jumpRateState: DecodedJumpRateState;
}

class Uint64Layout extends BufferLayout.Layout<bigint> {
    constructor(property?: string) {
        super(8, property);
    }

    decode(b: Uint8Array, offset = 0): bigint {
        const bn = new BN(b.slice(offset, offset + 8), 'le');
        return BigInt(bn.toString());
    }

    encode(src: bigint, b: Uint8Array, offset = 0): number {
        const bn = new BN(src.toString());
        const slice = b.slice(offset, offset + 8);
        bn.toArrayLike(Buffer, 'le', 8).copy(Buffer.from(slice));
        return 8;
    }
}

class BoolLayout extends BufferLayout.Layout<boolean> {
    constructor(property?: string) {
        super(1, property);
    }

    decode(b: Uint8Array, offset = 0): boolean {
        return !!b[offset];
    }

    encode(src: boolean, b: Uint8Array, offset = 0): number {
        b[offset] = +src;
        return 1;
    }
}

const u64 = (property?: string) => new Uint64Layout(property);
const bool = (property?: string) => new BoolLayout(property);

export const AssetsLayout: BufferLayout.Structure<DecodedAssets> = BufferLayout.struct([
    u64('feesReserves'),
    u64('owned'),
    u64('locked'),
    u64('guaranteedUsd'),
    u64('globalShortSizes'),
    u64('globalShortAveragePrices')
]);

export const FundingRateStateLayout: BufferLayout.Structure<DecodedFundingRateState> = BufferLayout.struct([
    u64('cumulativeInterestRate'),
    u64('lastUpdated'),
    u64('hourlyFundingDbps')
]);

export const JumpRateStateLayout: BufferLayout.Structure<DecodedJumpRateState> = BufferLayout.struct([
    u64('minRateBps'),
    u64('maxRateBps'),
    u64('targetRateBps'),
    u64('targetUtilizationRate')
]);

export const CustodyLayout: BufferLayout.Structure<DecodedCustody> = BufferLayout.struct([
    BufferLayout.seq(BufferLayout.u8(), 32, 'pool'),
    BufferLayout.seq(BufferLayout.u8(), 32, 'mint'),
    BufferLayout.seq(BufferLayout.u8(), 32, 'tokenAccount'),
    BufferLayout.u8('decimals'),
    bool('isStable'),
    AssetsLayout.replicate('assets'),
    FundingRateStateLayout.replicate('fundingRateState'),
    JumpRateStateLayout.replicate('jumpRateState')
]);

/**
 * Deserialize custody account data
 */
export function deserializeCustody(data: Buffer): DecodedCustody {
    return CustodyLayout.decode(data);
}

================
File: package.json
================
{
    "name": "@projects/jupiter-funding-rates",
    "version": "1.0.0",
    "scripts": {
        "test": "jest",
        "test:watch": "jest --watch",
        "test:coverage": "jest --coverage",
        "compare-rates": "ts-node scripts/compareRates.ts"
    },
    "dependencies": {
        "@heyanon/sdk": "^1.0.4",
        "@solana/buffer-layout": "^4.0.1",
        "@solana/web3.js": "^1.90.0",
        "bn.js": "^5.2.1",
        "buffer": "^6.0.3"
    },
    "devDependencies": {
        "@types/bn.js": "^5.1.6",
        "@types/jest": "^29.5.14",
        "@types/node": "^20.11.16",
        "jest": "^29.7.0",
        "ts-jest": "^29.1.2",
        "ts-node": "^10.9.2",
        "typescript": "^5.3.3"
    },
    "license": "MIT",
    "engines": {
        "npm": "please-use-yarn",
        "node": ">=18.x",
        "yarn": ">=1.22"
    }
}

================
File: README.md
================
# jupiter-funding-rates

Integration with Jupiter Funding Rates Data Streams

## Supported Networks

- SOLANA

## Common Tasks

1. Basic Operations
   - "Execute example operation with 100 USDT in @jupiter-funding-rates on Ethereum network"
   - "Run example transaction with 50 USDC in @jupiter-funding-rates"
   - "Perform example action with 1000 tokens in @jupiter-funding-rates"

2. Information Queries
   - "Show my current status in @jupiter-funding-rates"
   - "Check my balance in @jupiter-funding-rates"
   - "Get example statistics from @jupiter-funding-rates"
   - "Calculate expected results for my position in @jupiter-funding-rates"


## Available Functions

List of available functions will be added here.

## Installation

```bash
yarn add @heyanon/jupiter-funding-rates
```

## Usage

Example usage will be added here.

================
File: tools.ts
================
import { AiTool, getChainName } from '@heyanon/sdk';
import { supportedChains } from './constants';

export const tools: AiTool[] = [
    {
        name: 'getBorrowRates',
        description: 'Get current borrow rates for Jupiter Perpetuals markets',
        required: ['asset'],
        props: [
            {
                name: 'asset',
                type: 'string',
                enum: ['SOL', 'ETH', 'BTC', 'USDC', 'USDT'],
                description: 'Asset to get rates for',
            }
        ],
    },
    {
        name: 'getHistoricalRates',
        description: 'Get historical borrow rates for a specific market',
        required: ['asset', 'hours'],
        props: [
            {
                name: 'asset',
                type: 'string',
                enum: ['SOL', 'ETH', 'BTC', 'USDC', 'USDT'],
                description: 'Asset to get historical rates for',
            },
            {
                name: 'hours',
                type: 'number',
                description: 'Number of hours of history to retrieve (max 168)',
            }
        ],
    },
    {
        name: 'getMarketUtilization',
        description: 'Get current utilization rates for Jupiter Perpetuals markets',
        required: ['asset'],
        props: [
            {
                name: 'asset',
                type: 'string',
                enum: ['SOL', 'ETH', 'BTC', 'USDC', 'USDT'],
                description: 'Asset to get utilization for',
            }
        ],
    }
];

================
File: tsconfig.json
================
{
    "compilerOptions": {
      "target": "es2020",
      "module": "commonjs",
      "lib": ["es2020"],
      "declaration": true,
      "strict": true,
      "noImplicitAny": true,
      "strictNullChecks": true,
      "noImplicitThis": true,
      "alwaysStrict": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noImplicitReturns": true,
      "noFallthroughCasesInSwitch": true,
      "moduleResolution": "node",
      "baseUrl": ".",
      "types": ["node", "jest"],
      "esModuleInterop": true,
      "experimentalDecorators": true,
      "emitDecoratorMetadata": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "outDir": "./dist"
    },
    "include": [
      "src/**/*",
      "tests/**/*",
      "scripts/**/*"
    ],
    "exclude": ["node_modules", "dist"]
  }

================
File: types.ts
================
export const CUSTODY_ACCOUNTS = {
    SOL: '3NZ9JMVBmGAqocybic2c7LQCJScmgsAZ6vQqTDzcqmJh',
    ETH: 'AQCGyheWPLeo6Qp9WpYS9m3Qj479t7R636N9ey1rEjEn',
    BTC: '5Pv3gM9JrFFH883SWAhvJC9RPYmo8UNxuFtv5bMMALkm',
    USDC: 'G18jKKXQwBbrHeiK3C9MRXhkHsLHf7XgCSisykV46EZa',
    USDT: '4vkNeXiYEUizLdrpdPS1eC2mccyM4NUPRtERrk6ZETkk'
} as const;

export type AssetType = keyof typeof CUSTODY_ACCOUNTS;

export interface PerpsPosition {
    borrowRate: number;
    utilization: number;
    availableLiquidity: number;
}

export interface PerpsMarketData {
    long: PerpsPosition;
    short: PerpsPosition;
    openFee: number;
    timestamp: number;
}

export interface RateSnapshot {
    asset: AssetType;
    data: PerpsMarketData;
}

export interface HistoricalRates {
    asset: AssetType;
    snapshots: RateSnapshot[];
    period: {
        start: number;
        end: number;
    };
}
