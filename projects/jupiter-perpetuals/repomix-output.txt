This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-30T01:58:53.088Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
functions/
  getBorrowRates.ts
  getMarketUtilization.ts
  index.ts
services/
  accountMonitor.ts
tests/
  mocks/
    accountData.ts
  accountMonitor.test.ts
  getBorrowRates.test.ts
  layouts.test.ts
  setup.ts
.gitignore
.prettierrc
config.ts
constants.ts
index.ts
jest.config.js
layouts.ts
package.json
README.md
tools.ts
tsconfig.json
types.ts

================================================================
Files
================================================================

================
File: functions/getBorrowRates.ts
================
import { Connection, PublicKey } from '@solana/web3.js';
import type { FunctionReturn } from '@heyanon/sdk';
import { CUSTODY_ACCOUNTS, AssetType } from '../types';
import { deserializeCustody } from '../layouts';

interface Props {
    asset: AssetType;
}

export async function getBorrowRates({ asset }: Props): Promise<FunctionReturn> {
    try {
        if (!CUSTODY_ACCOUNTS[asset]) {
            return {
                success: false,
                data: `Invalid asset: ${asset}. Must be one of: ${Object.keys(CUSTODY_ACCOUNTS).join(', ')}`
            };
        }

        const connection = new Connection(process.env.SOLANA_RPC_URL || 'https://api.mainnet-beta.solana.com');
        const accountInfo = await connection.getAccountInfo(new PublicKey(CUSTODY_ACCOUNTS[asset]));
        
        if (!accountInfo) {
            return {
                success: false,
                data: `Failed to fetch account info for ${asset}`
            };
        }

        const custody = deserializeCustody(accountInfo.data);
        
        // Calculate utilization
        const utilization = custody.assets.owned > 0 
            ? custody.assets.locked / custody.assets.owned 
            : 0;

        // Calculate dual slope borrow rate
        const lowerSlope = (custody.jumpRateState.targetRateBps - custody.jumpRateState.minRateBps) 
            / custody.jumpRateState.targetUtilizationRate;
        const upperSlope = (custody.jumpRateState.maxRateBps - custody.jumpRateState.targetRateBps) 
            / (1 - custody.jumpRateState.targetUtilizationRate);

        let annualRateBps;
        if (utilization < custody.jumpRateState.targetUtilizationRate) {
            // Below target: minRate + slope * utilization
            annualRateBps = custody.jumpRateState.minRateBps + (lowerSlope * (utilization * 10000));
        } else {
            // Above target: targetRate + slope * (utilization - targetUtilization)
            annualRateBps = custody.jumpRateState.targetRateBps + 
                (upperSlope * ((utilization * 10000) - custody.jumpRateState.targetUtilizationRate));
        }

        const hourlyRateBps = annualRateBps / 8760;

        const rates = {
            asset,
            utilization: utilization * 100,       // Convert to percentage
            annualRate: annualRateBps / 100,      // Convert BPS to percentage
            hourlyRate: hourlyRateBps / 100,      // Convert BPS to percentage
            timestamp: Date.now()
        };

        return {
            success: true,
            data: JSON.stringify(rates)
        };
    } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        return {
            success: false,
            data: `Error fetching borrow rates: ${errorMessage}`
        };
    }
}

================
File: functions/getMarketUtilization.ts
================
import { FunctionReturn, toResult } from '@heyanon/sdk';
import { Connection, PublicKey } from '@solana/web3.js';
import { CUSTODY_ACCOUNTS, AssetType } from '../types';
import { deserializeCustodyAccount } from '../services/accountMonitor';

interface Props {
    asset: AssetType;
}

/**
 * Gets current utilization rates for a Jupiter Perpetuals market
 * @param props - The asset to get utilization for
 * @returns Current utilization data
 */
export async function getMarketUtilization({ asset }: Props): Promise<FunctionReturn> {
    try {
        if (!CUSTODY_ACCOUNTS[asset]) {
            return toResult(`Invalid asset: ${asset}. Must be one of: ${Object.keys(CUSTODY_ACCOUNTS).join(', ')}`, true);
        }

        const connection = new Connection(process.env.SOLANA_RPC_URL!);
        const accountInfo = await connection.getAccountInfo(new PublicKey(CUSTODY_ACCOUNTS[asset]));
        
        if (!accountInfo) {
            return toResult(`Failed to fetch account info for ${asset}`, true);
        }

        const custody = deserializeCustodyAccount(accountInfo.data);
        
        const utilization = {
            asset,
            totalTokens: custody.assets.owned,
            lockedTokens: custody.assets.locked,
            utilization: custody.assets.owned > 0 
                ? (custody.assets.locked / custody.assets.owned) * 100 
                : 0,
            globalShortSize: custody.assets.globalShortSizes,
            timestamp: Date.now()
        };

        return toResult(JSON.stringify(utilization));
    } catch (error) {
        return toResult(`Error fetching market utilization: ${error.message}`, true);
    }
}

================
File: functions/index.ts
================
export { getBorrowRates } from './getBorrowRates';
export { getMarketUtilization } from './getMarketUtilization';
export { getHistoricalRates } from './getHistoricalRates';

================
File: services/accountMonitor.ts
================
import { Connection, PublicKey } from '@solana/web3.js';
import { Buffer } from 'buffer';
import { CUSTODY_ACCOUNTS, AssetType } from '../types';
import { deserializeCustody, DecodedCustody } from '../layouts';

export interface RateData {
    utilization: number;
    annualRate: number;
    hourlyRate: number;
    timestamp: number;
}

export class AccountMonitor {
    private connection: Connection;
    private subscriptions: Map<string, number>;
    private rateCallbacks: Set<(asset: AssetType, rates: RateData) => void>;
    private lastProcessedSlot: Map<string, number>;
    private isRunning: boolean;

    constructor(rpcUrl: string = 'https://api.mainnet-beta.solana.com') {
        this.connection = new Connection(rpcUrl, 'confirmed');
        this.subscriptions = new Map();
        this.rateCallbacks = new Set();
        this.lastProcessedSlot = new Map();
        this.isRunning = false;
    }

    async start() {
        if (this.isRunning) {
            return;
        }

        this.isRunning = true;

        for (const [asset, address] of Object.entries(CUSTODY_ACCOUNTS)) {
            try {
                const pubkey = new PublicKey(address);
                
                // Subscribe to account changes
                const subId = this.connection.onAccountChange(
                    pubkey,
                    (account, context) => {
                        // Avoid processing duplicate updates
                        const lastSlot = this.lastProcessedSlot.get(asset) || 0;
                        if (context.slot > lastSlot) {
                            this.handleAccountUpdate(asset as AssetType, account.data);
                            this.lastProcessedSlot.set(asset, context.slot);
                        }
                    },
                    'confirmed'
                );
                this.subscriptions.set(asset, subId);

                // Get initial data
                const account = await this.connection.getAccountInfo(pubkey);
                if (account) {
                    this.handleAccountUpdate(asset as AssetType, account.data);
                }
            } catch (error) {
                console.error(`Error setting up monitor for ${asset}:`, error);
            }
        }
    }

    stop() {
        this.isRunning = false;
        for (const [asset, subId] of this.subscriptions.entries()) {
            try {
                this.connection.removeAccountChangeListener(subId);
            } catch (error) {
                console.error(`Error removing listener for ${asset}:`, error);
            }
        }
        this.subscriptions.clear();
        this.lastProcessedSlot.clear();
    }

    onRateUpdate(callback: (asset: AssetType, rates: RateData) => void) {
        this.rateCallbacks.add(callback);
        return () => {
            this.rateCallbacks.delete(callback);
        };
    }

    private handleAccountUpdate(asset: AssetType, data: Buffer) {
        try {
            const custody = deserializeCustody(data);
            const rates = this.calculateRates(custody);
            
            // Notify subscribers
            for (const callback of this.rateCallbacks) {
                callback(asset, rates);
            }
        } catch (error) {
            console.error(`Error processing ${asset} update:`, error);
        }
    }

    private calculateRates(custody: DecodedCustody): RateData {
        const { assets, jumpRateState } = custody;
        
        // Calculate utilization
        const utilization = assets.owned > 0 ? assets.locked / assets.owned : 0;

        // Calculate dual slope borrow rate
        const lowerSlope = (jumpRateState.targetRateBps - jumpRateState.minRateBps) 
            / jumpRateState.targetUtilizationRate;
        const upperSlope = (jumpRateState.maxRateBps - jumpRateState.targetRateBps) 
            / (1 - jumpRateState.targetUtilizationRate);

        let annualRate;
        if (utilization < jumpRateState.targetUtilizationRate) {
            annualRate = jumpRateState.minRateBps + (lowerSlope * utilization);
        } else {
            annualRate = jumpRateState.targetRateBps + 
                (upperSlope * (utilization - jumpRateState.targetUtilizationRate));
        }

        const hourlyRate = annualRate / 8760;

        return {
            utilization: utilization * 100,  // Convert to percentage
            annualRate: annualRate / 100,    // Convert BPS to percentage
            hourlyRate: hourlyRate / 100,    // Convert BPS to percentage
            timestamp: Date.now()
        };
    }

    async getCurrentRates(asset: AssetType): Promise<RateData | null> {
        try {
            const address = CUSTODY_ACCOUNTS[asset];
            if (!address) {
                return null;
            }

            const account = await this.connection.getAccountInfo(new PublicKey(address));
            if (!account) {
                return null;
            }

            const custody = deserializeCustody(account.data);
            return this.calculateRates(custody);
        } catch (error) {
            console.error(`Error getting current rates for ${asset}:`, error);
            return null;
        }
    }
}

export const accountMonitor = new AccountMonitor();
export default accountMonitor;

================
File: tests/mocks/accountData.ts
================
import { Buffer } from 'buffer';
import { BN } from 'bn.js';

// Helper function to create Buffer from u64
const u64ToBuffer = (num: number): Buffer => {
    return new BN(num).toArrayLike(Buffer, 'le', 8);
};

// Helper function to create mock account data
export function createMockCustodyAccount({
    owned = 1000000,
    locked = 500000,
    minRate = 1000, // 10% in BPS
    maxRate = 20000, // 200% in BPS
    targetRate = 5000, // 50% in BPS
    targetUtilization = 8000, // 80% in BPS
} = {}) {
    // Create a buffer large enough for the entire account data
    const buffer = Buffer.alloc(1024); // Adjust size as needed
    let offset = 0;

    // Mock pool, mint, and token account (32 bytes each of zeros is fine for testing)
    offset += 96; // 32 * 3

    // decimals (1 byte)
    buffer[offset] = 9;
    offset += 1;

    // isStable (1 byte)
    buffer[offset] = 0;
    offset += 1;

    // Assets
    u64ToBuffer(0).copy(buffer, offset); // feesReserves
    offset += 8;
    u64ToBuffer(owned).copy(buffer, offset); // owned
    offset += 8;
    u64ToBuffer(locked).copy(buffer, offset); // locked
    offset += 8;
    u64ToBuffer(0).copy(buffer, offset); // guaranteedUsd
    offset += 8;
    u64ToBuffer(0).copy(buffer, offset); // globalShortSizes
    offset += 8;
    u64ToBuffer(0).copy(buffer, offset); // globalShortAveragePrices
    offset += 8;

    // FundingRateState
    u64ToBuffer(0).copy(buffer, offset); // cumulativeInterestRate
    offset += 8;
    u64ToBuffer(Date.now()).copy(buffer, offset); // lastUpdated
    offset += 8;
    u64ToBuffer(0).copy(buffer, offset); // hourlyFundingDbps
    offset += 8;

    // JumpRateState
    u64ToBuffer(minRate).copy(buffer, offset); // minRateBps
    offset += 8;
    u64ToBuffer(maxRate).copy(buffer, offset); // maxRateBps
    offset += 8;
    u64ToBuffer(targetRate).copy(buffer, offset); // targetRateBps
    offset += 8;
    u64ToBuffer(targetUtilization).copy(buffer, offset); // targetUtilizationRate
    offset += 8;

    return buffer;
}

// Example test cases
export const mockAccountScenarios = {
    normalUtilization: createMockCustodyAccount({
        owned: 1000000,
        locked: 500000, // 50% utilization
    }),
    highUtilization: createMockCustodyAccount({
        owned: 1000000,
        locked: 900000, // 90% utilization
    }),
    lowUtilization: createMockCustodyAccount({
        owned: 1000000,
        locked: 100000, // 10% utilization
    }),
    zeroUtilization: createMockCustodyAccount({
        owned: 1000000,
        locked: 0, // 0% utilization
    }),
    fullUtilization: createMockCustodyAccount({
        owned: 1000000,
        locked: 1000000, // 100% utilization
    })
};

export * from './accountData';

================
File: tests/accountMonitor.test.ts
================
import { Connection } from '@solana/web3.js';
import { AccountMonitor } from '../services/accountMonitor';
import { mockAccountScenarios } from './mocks/accountData';
import { CUSTODY_ACCOUNTS } from '../types';

// Mock @solana/web3.js
jest.mock('@solana/web3.js', () => ({
    Connection: jest.fn(),
    PublicKey: jest.fn().mockImplementation((address) => ({ toBase58: () => address }))
}));

describe('AccountMonitor', () => {
    let monitor: AccountMonitor;
    let mockConnection: jest.Mocked<Connection>;

    beforeEach(() => {
        // Reset mocks
        jest.clearAllMocks();

        // Setup mock connection
        mockConnection = {
            onAccountChange: jest.fn().mockReturnValue(1),
            removeAccountChangeListener: jest.fn(),
            getAccountInfo: jest.fn().mockResolvedValue({
                data: mockAccountScenarios.normalUtilization,
                executable: false,
                lamports: 1000000,
                owner: 'owner',
            }),
        } as unknown as jest.Mocked<Connection>;

        (Connection as jest.Mock).mockImplementation(() => mockConnection);

        // Create monitor instance
        monitor = new AccountMonitor();
    });

    afterEach(() => {
        monitor.stop();
    });

    it('should initialize correctly', () => {
        expect(monitor).toBeDefined();
        expect(Connection).toHaveBeenCalled();
    });

    it('should start monitoring accounts', async () => {
        await monitor.start();

        expect(mockConnection.onAccountChange).toHaveBeenCalledTimes(Object.keys(CUSTODY_ACCOUNTS).length);
        expect(mockConnection.getAccountInfo).toHaveBeenCalledTimes(Object.keys(CUSTODY_ACCOUNTS).length);
    });

    it('should handle rate callbacks', async () => {
        const callback = jest.fn();
        monitor.onRateUpdate(callback);

        // Simulate account update
        const mockAccountChange = {
            data: mockAccountScenarios.normalUtilization,
            executable: false,
            lamports: 1000000,
            owner: 'owner',
        };

        await monitor.start();

        // Get the callback passed to onAccountChange
        const accountChangeCallback = (mockConnection.onAccountChange as jest.Mock).mock.calls[0][1];
        
        // Simulate account change
        accountChangeCallback(mockAccountChange, { slot: 1 });

        expect(callback).toHaveBeenCalled();
        const [_, rates] = callback.mock.calls[0];
        
        expect(rates).toHaveProperty('utilization');
        expect(rates).toHaveProperty('annualRate');
        expect(rates).toHaveProperty('hourlyRate');
        expect(rates).toHaveProperty('timestamp');
    });

    it('should calculate rates correctly for different utilization levels', async () => {
        const callback = jest.fn();
        monitor.onRateUpdate(callback);

        const testScenarios = [
            { name: 'normal', data: mockAccountScenarios.normalUtilization },
            { name: 'high', data: mockAccountScenarios.highUtilization },
            { name: 'low', data: mockAccountScenarios.lowUtilization },
            { name: 'zero', data: mockAccountScenarios.zeroUtilization },
            { name: 'full', data: mockAccountScenarios.fullUtilization },
        ];

        for (const scenario of testScenarios) {
            const mockAccountChange = {
                data: scenario.data,
                executable: false,
                lamports: 1000000,
                owner: 'owner',
            };

            await monitor.start();
            const accountChangeCallback = (mockConnection.onAccountChange as jest.Mock).mock.calls[0][1];
            accountChangeCallback(mockAccountChange, { slot: 1 });

            expect(callback).toHaveBeenCalled();
            const [_, rates] = callback.mock.lastCall;
            
            expect(rates.utilization).toBeGreaterThanOrEqual(0);
            expect(rates.utilization).toBeLessThanOrEqual(100);
            expect(rates.annualRate).toBeGreaterThanOrEqual(0);
            expect(rates.hourlyRate).toBeGreaterThanOrEqual(0);
        }
    });

    it('should handle cleanup correctly', async () => {
        await monitor.start();
        monitor.stop();

        expect(mockConnection.removeAccountChangeListener).toHaveBeenCalledTimes(Object.keys(CUSTODY_ACCOUNTS).length);
    });

    it('should prevent duplicate starts', async () => {
        await monitor.start();
        await monitor.start(); // Second start should be ignored

        expect(mockConnection.onAccountChange).toHaveBeenCalledTimes(Object.keys(CUSTODY_ACCOUNTS).length);
    });

    it('should handle connection errors gracefully', async () => {
        mockConnection.getAccountInfo.mockRejectedValueOnce(new Error('Connection failed'));

        await monitor.start();
        // Should not throw error and continue with other accounts
        expect(mockConnection.onAccountChange).toHaveBeenCalled();
    });
});

================
File: tests/getBorrowRates.test.ts
================
import { Connection } from '@solana/web3.js';
import type { FunctionReturn } from '@heyanon/sdk';
import { getBorrowRates } from '../functions/getBorrowRates';
import { CUSTODY_ACCOUNTS } from '../types';
import { createMockCustodyAccount } from './mocks/accountData';

// Mock @solana/web3.js
jest.mock('@solana/web3.js', () => ({
    Connection: jest.fn(),
    PublicKey: jest.fn().mockImplementation((address) => ({ toBase58: () => address }))
}));

describe('getBorrowRates', () => {
    const mockAccountData = createMockCustodyAccount({
        owned: 1000000,
        locked: 500000,      // 50% utilization
        minRate: 1000,       // 10% annual rate
        maxRate: 20000,      // 200% annual rate
        targetRate: 5000,    // 50% annual rate
        targetUtilization: 8000 // 80% target utilization
    });

    beforeEach(() => {
        // Reset mocks
        (Connection as jest.Mock).mockClear();
        
        // Setup default mock implementations
        (Connection as jest.Mock).mockImplementation(() => ({
            getAccountInfo: jest.fn().mockResolvedValue({
                data: mockAccountData,
                executable: false,
                lamports: 1000000,
                owner: CUSTODY_ACCOUNTS.SOL,
            })
        }));
    });

    it('should return borrow rates for valid asset', async () => {
        const result: FunctionReturn = await getBorrowRates({ asset: 'SOL' });
        expect(result.success).toBe(true);
        
        const data = JSON.parse(result.data);
        expect(data).toHaveProperty('asset', 'SOL');
        expect(data).toHaveProperty('utilization');
        expect(data).toHaveProperty('annualRate');
        expect(data).toHaveProperty('hourlyRate');
        expect(data).toHaveProperty('timestamp');
        
        // Test specific values based on our mock data
        expect(data.utilization).toBe(50); // 50% utilization
        expect(data.annualRate).toBeCloseTo(35, 1); // Should be around 35% with our mock values
        // 35% because: minRate(10%) + (targetRate(50%) - minRate(10%)) * (utilization(50%) / targetUtilization(80%))
    });

    it('should handle invalid assets', async () => {
        // @ts-ignore - Testing invalid input
        const result: FunctionReturn = await getBorrowRates({ asset: 'INVALID' });
        expect(result.success).toBe(false);
        expect(result.data).toContain('Invalid asset');
    });

    it('should handle RPC errors', async () => {
        // Mock RPC failure
        (Connection as jest.Mock).mockImplementation(() => ({
            getAccountInfo: jest.fn().mockRejectedValue(new Error('RPC Error'))
        }));

        const result: FunctionReturn = await getBorrowRates({ asset: 'SOL' });
        expect(result.success).toBe(false);
        expect(result.data).toContain('Error fetching borrow rates');
    });

    it('should handle missing account data', async () => {
        // Mock missing account
        (Connection as jest.Mock).mockImplementation(() => ({
            getAccountInfo: jest.fn().mockResolvedValue(null)
        }));

        const result: FunctionReturn = await getBorrowRates({ asset: 'SOL' });
        expect(result.success).toBe(false);
        expect(result.data).toContain('Failed to fetch account info');
    });

    it('should calculate rates correctly for different utilization levels', async () => {
        // Test with 90% utilization (above target)
        const highUtilData = createMockCustodyAccount({
            owned: 1000000,
            locked: 900000,  // 90% utilization
            minRate: 1000,   // 10%
            maxRate: 20000,  // 200%
            targetRate: 5000, // 50%
            targetUtilization: 8000 // 80%
        });

        (Connection as jest.Mock).mockImplementation(() => ({
            getAccountInfo: jest.fn().mockResolvedValue({
                data: highUtilData,
                executable: false,
                lamports: 1000000,
                owner: CUSTODY_ACCOUNTS.SOL,
            })
        }));

        const result: FunctionReturn = await getBorrowRates({ asset: 'SOL' });
        expect(result.success).toBe(true);
        
        const data = JSON.parse(result.data);
        expect(data.utilization).toBe(90);
        // For 90% utilization (above target):
        // Using upper slope: targetRate + (maxRate - targetRate) * (utilization - targetUtilization)/(1 - targetUtilization)
        // 50% + (200% - 50%) * (90% - 80%)/(100% - 80%) = 87.5%
        expect(data.annualRate).toBeCloseTo(87.5, 1);
        expect(data.hourlyRate).toBeCloseTo(data.annualRate / 8760, 5);
    });
});

================
File: tests/layouts.test.ts
================
import { deserializeCustody } from '../layouts';
import { mockAccountScenarios, createMockCustodyAccount } from './mocks/accountData';

describe('Layout Deserialization', () => {
    it('should correctly deserialize a custody account with normal utilization', () => {
        const decoded = deserializeCustody(mockAccountScenarios.normalUtilization);
        
        expect(decoded.assets.owned).toBe(1000000);
        expect(decoded.assets.locked).toBe(500000);
        expect(decoded.jumpRateState.minRateBps).toBe(1000);
        expect(decoded.jumpRateState.maxRateBps).toBe(20000);
        expect(decoded.jumpRateState.targetRateBps).toBe(5000);
        expect(decoded.jumpRateState.targetUtilizationRate).toBe(8000);
    });

    it('should handle accounts with zero values', () => {
        const decoded = deserializeCustody(mockAccountScenarios.zeroUtilization);
        
        expect(decoded.assets.owned).toBe(1000000);
        expect(decoded.assets.locked).toBe(0);
        expect(decoded.assets.feesReserves).toBe(0);
        expect(decoded.assets.guaranteedUsd).toBe(0);
    });

    it('should correctly handle custom account data', () => {
        const custom = createMockCustodyAccount({
            owned: 5000000,
            locked: 2500000,
            minRate: 500,
            maxRate: 15000,
            targetRate: 3000,
            targetUtilization: 7000
        });

        const decoded = deserializeCustody(custom);
        
        expect(decoded.assets.owned).toBe(5000000);
        expect(decoded.assets.locked).toBe(2500000);
        expect(decoded.jumpRateState.minRateBps).toBe(500);
        expect(decoded.jumpRateState.maxRateBps).toBe(15000);
        expect(decoded.jumpRateState.targetRateBps).toBe(3000);
        expect(decoded.jumpRateState.targetUtilizationRate).toBe(7000);
    });

    it('should preserve boolean values', () => {
        const decoded = deserializeCustody(mockAccountScenarios.normalUtilization);
        expect(typeof decoded.isStable).toBe('boolean');
    });

    it('should handle numbers without precision loss', () => {
        const largeNumber = 2**53 - 1; // Max safe integer
        const custom = createMockCustodyAccount({
            owned: largeNumber,
            locked: largeNumber / 2
        });

        const decoded = deserializeCustody(custom);
        expect(decoded.assets.owned).toBe(largeNumber);
        expect(decoded.assets.locked).toBe(Math.floor(largeNumber / 2));
    });
});

================
File: tests/setup.ts
================
process.env.SOLANA_RPC_URL = 'https://api.mainnet-beta.solana.com';

================
File: .gitignore
================
node_modules

================
File: .prettierrc
================
{
    "singleQuote": true,
    "trailingComma": "all",
    "tabWidth": 4,
    "printWidth": 180
}

================
File: config.ts
================
export const config = {
    rpcUrl: process.env.SOLANA_RPC_URL || 'https://api.mainnet-beta.solana.com',
    // Add other configuration settings here as needed
    snapshot: {
        interval: 5 * 60 * 1000,  // 5 minutes in milliseconds
        maxHistory: 168,          // Maximum hours of history to keep (1 week)
    },
    retry: {
        maxAttempts: 3,
        delay: 1000,              // 1 second between retries
    }
} as const;

================
File: constants.ts
================
import { ChainId } from '@heyanon/sdk';

export const supportedChains = [ChainId.SOLANA];

================
File: index.ts
================
import { AdapterExport } from '@heyanon/sdk'';
import { tools } from './tools';
import * as functions from './functions';

export default {
    tools,
    functions,
    description: 'Integration with Jupiter Funding Rates Data Streams',
} satisfies AdapterExport;

================
File: jest.config.js
================
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    roots: ['<rootDir>/tests'],
    testMatch: ['**/*.test.ts'],
    moduleNameMapper: {
      '^@/(.*)$': '<rootDir>/$1',
    },
    setupFiles: ['<rootDir>/tests/setup.ts'],
  };

================
File: layouts.ts
================
import { Buffer } from 'buffer';
import * as BufferLayout from '@solana/buffer-layout';
import { BN } from 'bn.js';

export interface DecodedAssets {
    feesReserves: number;
    owned: number;
    locked: number;
    guaranteedUsd: number;
    globalShortSizes: number;
    globalShortAveragePrices: number;
}

export interface DecodedFundingRateState {
    cumulativeInterestRate: number;
    lastUpdated: number;
    hourlyFundingDbps: number;
}

export interface DecodedJumpRateState {
    minRateBps: number;
    maxRateBps: number;
    targetRateBps: number;
    targetUtilizationRate: number;
}

export interface DecodedCustody {
    pool: number[];
    mint: number[];
    tokenAccount: number[];
    decimals: number;
    isStable: boolean;
    assets: DecodedAssets;
    fundingRateState: DecodedFundingRateState;
    jumpRateState: DecodedJumpRateState;
}

class Uint64Layout extends BufferLayout.Layout<number> {
    constructor(property?: string) {
        super(8, property);
    }

    decode(b: Uint8Array, offset = 0): number {
        const num = new BN(b.slice(offset, offset + 8), 'le');
        return num.toNumber();
    }

    encode(src: number, b: Uint8Array, offset = 0): number {
        const bn = new BN(src);
        const slice = b.slice(offset, offset + 8);
        bn.toArrayLike(Buffer, 'le', 8).copy(Buffer.from(slice));
        return 8;
    }
}

class BoolLayout extends BufferLayout.Layout<boolean> {
    constructor(property?: string) {
        super(1, property);
    }

    decode(b: Uint8Array, offset = 0): boolean {
        return !!b[offset];
    }

    encode(src: boolean, b: Uint8Array, offset = 0): number {
        b[offset] = +src;
        return 1;
    }
}

const u64 = (property?: string) => new Uint64Layout(property);
const bool = (property?: string) => new BoolLayout(property);

export const AssetsLayout: BufferLayout.Structure<DecodedAssets> = BufferLayout.struct([
    u64('feesReserves'),
    u64('owned'),
    u64('locked'),
    u64('guaranteedUsd'),
    u64('globalShortSizes'),
    u64('globalShortAveragePrices')
]);

export const FundingRateStateLayout: BufferLayout.Structure<DecodedFundingRateState> = BufferLayout.struct([
    u64('cumulativeInterestRate'),
    u64('lastUpdated'),
    u64('hourlyFundingDbps')
]);

export const JumpRateStateLayout: BufferLayout.Structure<DecodedJumpRateState> = BufferLayout.struct([
    u64('minRateBps'),
    u64('maxRateBps'),
    u64('targetRateBps'),
    u64('targetUtilizationRate')
]);

export const CustodyLayout: BufferLayout.Structure<DecodedCustody> = BufferLayout.struct([
    BufferLayout.seq(BufferLayout.u8(), 32, 'pool'),
    BufferLayout.seq(BufferLayout.u8(), 32, 'mint'),
    BufferLayout.seq(BufferLayout.u8(), 32, 'tokenAccount'),
    BufferLayout.u8('decimals'),
    bool('isStable'),
    AssetsLayout.replicate('assets'),
    FundingRateStateLayout.replicate('fundingRateState'),
    JumpRateStateLayout.replicate('jumpRateState')
]);

/**
 * Deserialize custody account data
 */
export function deserializeCustody(data: Buffer): DecodedCustody {
    return CustodyLayout.decode(data);
}

================
File: package.json
================
{
    "name": "@projects/jupiter-funding-rates",
    "version": "1.0.0",
    "scripts": {
        "test": "jest",
        "test:watch": "jest --watch",
        "test:coverage": "jest --coverage"
    },
    "dependencies": {
        "@heyanon/sdk": "^1.0.4",
        "@solana/buffer-layout": "^4.0.1",
        "@solana/web3.js": "^1.90.0",
        "bn.js": "^5.2.1",
        "buffer": "^6.0.3"
    },
    "devDependencies": {
        "@types/bn.js": "^5.1.6",
        "@types/jest": "^29.5.12",
        "@types/node": "^20.11.16",
        "jest": "^29.7.0",
        "ts-jest": "^29.1.2",
        "typescript": "^5.3.3"
    },
    "license": "MIT",
    "engines": {
        "npm": "please-use-yarn",
        "node": ">=18.x",
        "yarn": ">=1.22"
    }
}

================
File: README.md
================
# jupiter-funding-rates

Integration with Jupiter Funding Rates Data Streams

## Supported Networks

- SOLANA

## Common Tasks

1. Basic Operations
   - "Execute example operation with 100 USDT in @jupiter-funding-rates on Ethereum network"
   - "Run example transaction with 50 USDC in @jupiter-funding-rates"
   - "Perform example action with 1000 tokens in @jupiter-funding-rates"

2. Information Queries
   - "Show my current status in @jupiter-funding-rates"
   - "Check my balance in @jupiter-funding-rates"
   - "Get example statistics from @jupiter-funding-rates"
   - "Calculate expected results for my position in @jupiter-funding-rates"


## Available Functions

List of available functions will be added here.

## Installation

```bash
yarn add @heyanon/jupiter-funding-rates
```

## Usage

Example usage will be added here.

================
File: tools.ts
================
import { AiTool, getChainName } from '@heyanon/sdk';
import { supportedChains } from './constants';

export const tools: AiTool[] = [
    {
        name: 'getBorrowRates',
        description: 'Get current borrow rates for Jupiter Perpetuals markets',
        required: ['asset'],
        props: [
            {
                name: 'asset',
                type: 'string',
                enum: ['SOL', 'ETH', 'BTC', 'USDC', 'USDT'],
                description: 'Asset to get rates for',
            }
        ],
    },
    {
        name: 'getHistoricalRates',
        description: 'Get historical borrow rates for a specific market',
        required: ['asset', 'hours'],
        props: [
            {
                name: 'asset',
                type: 'string',
                enum: ['SOL', 'ETH', 'BTC', 'USDC', 'USDT'],
                description: 'Asset to get historical rates for',
            },
            {
                name: 'hours',
                type: 'number',
                description: 'Number of hours of history to retrieve (max 168)',
            }
        ],
    },
    {
        name: 'getMarketUtilization',
        description: 'Get current utilization rates for Jupiter Perpetuals markets',
        required: ['asset'],
        props: [
            {
                name: 'asset',
                type: 'string',
                enum: ['SOL', 'ETH', 'BTC', 'USDC', 'USDT'],
                description: 'Asset to get utilization for',
            }
        ],
    }
];

================
File: tsconfig.json
================
{
    "compilerOptions": {
      "target": "es2020",
      "module": "commonjs",
      "lib": ["es2020"],
      "declaration": true,
      "strict": true,
      "noImplicitAny": true,
      "strictNullChecks": true,
      "noImplicitThis": true,
      "alwaysStrict": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noImplicitReturns": true,
      "noFallthroughCasesInSwitch": true,
      "moduleResolution": "node",
      "baseUrl": ".",
      "types": ["node", "jest"],
      "esModuleInterop": true,
      "experimentalDecorators": true,
      "emitDecoratorMetadata": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "outDir": "./dist"
    },
    "include": ["**/*.ts"],
    "exclude": ["node_modules", "dist"]
  }

================
File: types.ts
================
import { PublicKey } from '@solana/web3.js';

export interface Assets {
    feesReserves: number;
    owned: number;
    locked: number;
    guaranteedUsd: number;
    globalShortSizes: number;
    globalShortAveragePrices: number;
}

export interface FundingRateState {
    cumulativeInterestRate: number;
    lastUpdated: number;
    hourlyFundingDbps: number;
}

export interface JumpRateState {
    minRateBps: number;
    maxRateBps: number;
    targetRateBps: number;
    targetUtilizationRate: number;
}

export interface CustodyAccount {
    pool: PublicKey;
    mint: PublicKey;
    tokenAccount: PublicKey;
    decimals: number;
    isStable: boolean;
    assets: Assets;
    fundingRateState: FundingRateState;
    jumpRateState: JumpRateState;
}

export const CUSTODY_ACCOUNTS = {
    SOL: '7xS2gz2bTp3fwCC7knJvUWTEU9Tycczu6VhJYKgi1wdz',
    ETH: 'AQCGyheWPLeo6Qp9WpYS9m3Qj479t7R636N9ey1rEjEn',
    BTC: '5Pv3gM9JrFFH883SWAhvJC9RPYmo8UNxuFtv5bMMALkm',
    USDC: 'G18jKKXQwBbrHeiK3C9MRXhkHsLHf7XgCSisykV46EZa',
    USDT: '4vkNeXiYEUizLdrpdPS1eC2mccyM4NUPRtERrk6ZETkk'
} as const;

export type AssetType = keyof typeof CUSTODY_ACCOUNTS;
